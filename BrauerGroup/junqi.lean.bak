-- open Polynomial
-- abbrev f_a : Polynomial K := X^2 - a • 1

-- instance f_a_irr (ha : ¬ ∃ y, a = y ^ 2): Irreducible (f_a a) := by
--   unfold f_a; rw [irreducible_iff]
--   constructor
--   · by_contra! h
--     rw [Polynomial.isUnit_iff_degree_eq_zero, sub_eq_neg_add] at h
--     have h1 :=  Polynomial.eq_C_of_degree_eq_zero h
--     simp only [coeff_add, coeff_neg, coeff_smul, coeff_one_zero, smul_eq_mul, mul_one, coeff_X_pow,
--       OfNat.zero_ne_ofNat, ↓reduceIte, add_zero, map_neg] at h1
--     rw [Algebra.smul_def, algebraMap_eq, mul_one] at h1
--     simp at h1
--   · intro h g h1
--     by_contra! hhg
--     rw [Algebra.smul_def, algebraMap_eq, mul_one] at h1
--     have h_ne_zero : h ≠ 0 := by
--       by_contra!
--       simp only [this, zero_mul] at h1
--       exact (Polynomial.X_pow_sub_C_ne_zero (by omega) a) h1
--     have g_ne_zero : g ≠ 0 := by
--       by_contra!
--       simp only [this, mul_zero] at h1
--       exact (Polynomial.X_pow_sub_C_ne_zero (by omega) a) h1
--     obtain ⟨hh, hg⟩ := hhg
--     have hh := Polynomial.degree_pos_of_ne_zero_of_nonunit h_ne_zero hh
--     have hg := Polynomial.degree_pos_of_ne_zero_of_nonunit g_ne_zero hg
--     have h2 : h.degree + g.degree = 2 := by
--       rw [← degree_mul, ← h1, Polynomial.degree_X_pow_sub_C (by omega), Nat.cast_ofNat]
--     rw [Polynomial.degree_eq_natDegree h_ne_zero, Polynomial.degree_eq_natDegree g_ne_zero] at *
--     norm_cast at hh hg h2
--     have hh : h.natDegree = 1 := by omega
--     have hg : g.natDegree = 1 := by omega
--     obtain ⟨m, ⟨_, ⟨n, hn⟩⟩⟩ := Polynomial.natDegree_eq_one.1 hh
--     obtain ⟨p, ⟨gp, ⟨q, gq⟩⟩⟩ := Polynomial.natDegree_eq_one.1 hg
--     rw [← hn, ← gq] at h1
--     ring_nf at h1
--     rw [Polynomial.ext_iff] at h1
--     obtain l0 := h1 0
--     obtain l1 := (h1 1).symm
--     obtain l2 := h1 2
--     simp only [coeff_sub, coeff_X_pow, OfNat.zero_ne_ofNat, ↓reduceIte, coeff_C_zero, zero_sub,
--       X_mul_C, X_pow_mul_C, X_pow_mul_assoc_C, coeff_add, mul_coeff_zero, coeff_X_zero, mul_zero,
--       zero_mul, add_zero, zero_add, OfNat.one_ne_ofNat, coeff_C_succ, sub_self, coeff_mul_C,
--       coeff_mul_X, sub_zero] at l0 l1 l2
--     rw [mul_assoc, mul_comm, coeff_mul_C] at l2
--     nth_rewrite 2 [mul_comm] at l2
--     rw [coeff_mul_C, coeff_X_pow] at l2
--     simp only [↓reduceIte, one_mul] at l2
--     rw [mul_assoc] at l1
--     nth_rewrite 3 [mul_comm] at l1
--     rw [coeff_mul_C] at l1
--     nth_rewrite 4 [mul_comm] at l1
--     rw [coeff_mul_C, coeff_X_pow] at l1
--     simp only [OfNat.one_ne_ofNat, ↓reduceIte, zero_mul, add_zero] at l1
--     apply ha
--     use q / p
--     rw [div_pow, neg_eq_iff_eq_neg.1 l0, pow_two, neg_mul_eq_neg_mul, mul_comm, ← mul_div_assoc']
--     congr
--     rw [neg_eq_iff_eq_neg, ← neg_div, eq_div_iff_mul_eq, pow_two]
--     · rw [← neg_eq_iff_add_eq_zero] at l1
--       rw [← mul_assoc, ← l1, neg_mul, neg_inj]
--       nth_rewrite 2 [mul_comm]
--       rw [mul_comm] at l2
--       rw [mul_assoc, ← l2, mul_one]
--     · rw [pow_ne_zero_iff]
--       exact gp
--       norm_num

-- instance (ha : ¬ ∃ y, a = y ^ 2) : Field (AdjoinRoot (f_a a)) := by
--   exact @AdjoinRoot.instField (f := f_a a) (fact_iff.2 (f_a_irr a ha))

-- local notation "K(√"a")" => Algebra.adjoin K {√a}